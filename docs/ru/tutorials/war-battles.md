---
название: Учебник War Battles
описание: Этот учебник поможет вам создать заготовку маленькой игры-стрелялки. Это хорошая отправная точка для новичоков в Defold.
---

# Учебник War Battles

В этих уроках мы пройдем все шаги, необходимые для создания несложной заготовки игры в Defold. Урок рассчитан на людей, не имеющих опыта работы с Defold, однако, если вы знакомы с Lua, Javascript, Python, это облегчит понимание.

::: important
Внимание! Сейчас мы переходим на новый редактор - Defold 2, который в настоящее время находится в режиме альфа-тестирования. Это руководство написано для нового редактора, но большинство моментов будут работать и в первом редакторе. Скачать и опробовать новый редактор можно тут: [Новый редактор](https://www.defold.com/editor-two/).
:::

Чтобы понимать, что мы собираемся сделать, можете попробовать конечный результат здесь:

<div id="game-container" class="game-container">
    <img id="game-preview" src="//storage.googleapis.com/defold-doc/assets/war-battles/preview.jpg"/>
    <canvas id="game-canvas" tabindex="1" width="720" height="720">
    </canvas>
    <button id="game-button">
        START GAME <span class="icon"></span>
    </button>
    <script src="//storage.googleapis.com/defold-doc/assets/dmloader.js"></script>
    <script src="//storage.googleapis.com/defold-doc/assets/dmengine_1_2_106.js" async></script>
    <script>
        /* Load app on click in container. */
        document.getElementById("game-button").onclick = function (e) {
            var extra_params = {
                archive_location_filter: function( path ) {
                    return ("//storage.googleapis.com/defold-doc/assets/war-battles" + path + "");
                },
                load_done: function() {},
                game_start: function() {
                    var e = document.getElementById("game-preview");
                    e.parentElement.removeChild(e);
                }
            }
            Module.runApp("game-canvas", extra_params);
            document.getElementById("game-button").style.display = 'none';
            document.getElementById("game-button").onclick = null;
        };
    </script>
</div>

## Настройка проекта

Прежде чем начать, вам необходимо создать новый проект в Defold Dashboard и скачать архив с материалами для создания игры.

1.	Откройте страницу [Defold Dashboard](//dashboard.defold.com)
2.	Нажмите на *New Project*
3.	Введите название вашего проекта и выберите пункт «Start from a blank slate» (начать с чистого листа).

   ![create project](images/war-battles/create_project.png)

4.	Запустите Defold.
5.	Нажмите на «From Dashboard» в меню Open project.

   ![open from dashboard](images/war-battles/from_dashboard.png)

6.	Выберите только что созданный проект и место на жестком диске, где сохранится его рабочая копия.

   ![import](images/war-battles/import_project.png)

После этого откроется рабочая область редактора.

## Обзор редактора

Давайте потратим минутку на ознакомление с рабочими областями редактора.
1.	В области Assets отображаются все файлы, включенные в проект. Кликните по папкам, чтобы развернуть их и увидеть вложенные файлы. Для всех файлов в этой зоне доступны следующие действия:
•	Двойной клик – откроет файл для редактирования (в подходящем редакторе).
•	Перетаскивание – для перемещения файла или папки в другое место.
•	Правый клик – для открытия контекстного меню, в котором можно создать новые файлы/папки, переименовывать их, удалять, отслеживать зависимости и т.д.
2.	В центре редактора находится область просмотра, в которой отображается текущий открытый файл. Если вы открываете файл для визуального редактирования (относящийся к графике), в правом верхнем углу появится панель инструментов, с помощью которых можно перемещать, вращать и масштабировать элементы. При этом доступна возможность изменять вид камеры:
•	Вращение колеса мыши – для изменения масштаба.
•	Alt + ЛКМ - для перемещения всей области обзора
•	Ctrl + ЛКМ – для поворота области обзора в 3D
•	Меню Scene > Camera включает в себя инструменты, позволяющие отобразить выделенный элемент или сбросить настройки камеры. Данный пункт неактуален для обновленной версии редактора. Используйте клавиши [F] для фокуса на выбранном элементе и [.] для сброса камеры.
3.	В области Outline показывается содержимое редактируемого файла, но в иерархической древовидной структуре. Здесь удобно работать со сборками (коллекциями) файлов и можно делать следующее:
•	Клик по элементу – чтобы выделить его. Удерживая Shift можно выделить несколько элементов.
•	Перетаскивание – чтобы переместить элемент и изменить его место в иерархии редактируемого файла.
•	Правый клик – чтобы открыть всплывающее меню, в котором есть пункты для добавления/удаления элементов и т.д.
4.	В области Properties отображаются различные свойства выбранного элемента, такие как позиция, углы поворота, параметры анимации и т.д.
5.	Область Console во время запуска проекта предоставляет всю отладочную информацию, ошибки вывода и другую техническую информацию. Здесь так же есть вкладка Curve Editor, которая используется для редактирования кривых в редакторе частиц; вкладка Build Errors, отображающая ошибки компиляцц; и вкладка Search results, для вывода результатов поиска.
6.	И, наконец, область Changed Files, в которой ведется список всех файлов проекта, которые были изменены, добавлены или удалены. Используя функции синхронизации, вы можете включать изменения, сделанные в локальной копии, в проект команды, который хранится в Git-репозитарии. Так же это позволит сохранить работу, если с вашей локальной копией случится какая-нибудь неприятность. Доступные действия в этой области:
•	Двойной клик – для открытия файла в редакторе (так же, как и из области Assets).
•	Правый клик – для открытия контекстного меню, с помощью которого можно отменить все изменения, внесенные в файл, найти его в файловой системе и многое другое.

Очистка проекта
Новый проект не является на 100% пустым, поэтому давайте это исправим:
1.	Откройте файл «main/main.collection».
2.	Выделите объект «logo» в области просмотра (или на панели Outline).
3.	Удалите объект.
4.	Удалите файл «main/images/logo.png» (найдите его на панели Assets).
5.	Удалите файл «main/logo.atlas» (ищите там же).
Теперь проект полностью чистый. Вы можете убедиться в этом, используя пункты меню Project > Build. Эта команда запустит игру, но сейчас ничего, кроме черного окна, вы не увидите.

Рисуем карту игры
Нашей игре нужна карта и рисовать ее мы будем, используя тайлы (плитки), которые являются небольшими кусочками картинки. Из них, как мозаику, мы будем собирать общую большую картинку. В Defold она называется Tile map. Чтобы ее создать, для начала необходимо импортировать графический файл, в котором изображены наши тайлы. Затем нужно будет указать размер тайлов, границ и расстояния между ними в этой картинке. Эти настройки делаются в файле, который называется Tile source.
1.	Скачайте архив с материалами для «War Battles», сохраните на свой жесткий диск и распакуйте. <ссылка на архив>
2.	Перетащите файл «map.png», в котором нарисованы все тайлы, из папки с материалами в папку «main» в область Assets.
3.	Кликните правой кнопкой мыши по папке main и выберите New > Tile source, чтобы создать новый файл с тайлами. Назовите его «map» (полное название будет «map.tilesource».
4.	Созданный файл автоматически откроется в редакторе. Теперь нужно подгрузить в него файл с изображениями тайлов. Для этого нужно в свойствах в параметре Image указать путь к картинке. Проще всего это сделать, нажав на кнопку обзора ресурсов ([…] - справа от параметра Image), и выбрать в списке «main/map.png».
Тайлы в нашей картинке имеют размер 16х16 пикселей, без полей, поэтому нет необходимости дополнительно менять параметры данного Tile Source.
5.	Нажмите правой кнопкой мыши по папке main и выберите New > Tile map. Назовите его «map» (полное название будет «map.tilemap»). После создания файл автоматический откроется для редактирования.
6.	Для параметра Tile source установите значение «main/map.tilesource».
7.	Выделите слой «layer1» у созданного Tile Map в панели Outline.
8.	Выберите пункт меню Scene > Tile map > Show palette. Это отобразит набор плиток. Данный пункт неактуален для обновленной версии редактора. Используйте меню Edit > Select Tile или клавишу [Пробел]. 
9.	Выберите тайл с травой. При клике по нему, эта плитка установится в качестве рабочей кисти. Теперь нарисуйте поверхность, как пожелаете. Возвращаться к выбору тайлов можно так же, нажимая клавишу [Пробел] .
10.	Удерживая Shift, можно выделить несколько тайлов, после чего ваша кисть изменится и будет рисовать уже сразу несколькими тайлами. Это хороший способ быстро закрасить большую зону карты.
Ну, и теперь, когда вы довольны нарисованной картой, пришло время добавить ее в игру.

Добавление карты в игру

Все, что вы создаете, в Defold хранится в сборках файлов, которых называются collections (коллекции). Это контейнер, в котором хранятся игровые объекты. Помимо объектов, Сборка может так же хранить в себе другие сборки. В файле «game.project» вы указываете сборку, которая будет загружаться при запуске игры. По умолчанию задан файл сборки «/main/main.collection».
1.	Откройте файл «main.collection».
2.	В панели Outline кликните правой кнопкой мыши по файлу и выберите в выпадающем меню пункт Add game object.
3.	Измените параметр Id объекта на «map». Название идентификатор не имеет особого значения для этого объекта, но давать идентификаторам уникальные и понятные названия – это хорошая привычка. Кроме того, это сильно облегчает ориентирование в игровом проекте, который включает в себя большое количество объектов.
4.	Кликните правой кнопкой мыши по новому объекту («map») и выберите Add Component File.
5.	В списке ресурсов кликните на файле «/main/map.tilemap». После этого ваша карта должна появится в окне редактора.
6.	Запустите игру (Project > Build) и убедитесь, что все выглядит хорошо. Если вам кажется, что окно игры слишком большое, вы можете открыть файл game.project и изменить значения длины и высоты экрана.
Анимация игрока
1.	Перетащите папку units/infantry из папки материалов в папку main в панели Assets. Это импортирует в игру набор файлов с изображениями и анимациями игрока. Они разделены по папкам, по одной для каждого направления.
2.	Кликните правой кнопкой мыши по папке main в панели Assets и выберите в меню New > Atlas. Назовите новый файл атласа «sprites» (полное название будет «sprites.atlas»).
3.	В панели Outline кликните правой кнопкой по созданному атласу и выберите Add Animation Group.
4.	Выделите появившийся элемент New Animation и измените название Id на «player-down».
5.	Теперь кликните правой кнопкой по этой анимации и выберите Add Images… . В списке ресурсов выберите все изображения с /main/infantry/down/1.png до /main/infantry/down/4.png.
6.	Убедитесь, что анимация выделена и нажмите [Пробел] или пункт меню View > Play, чтобы посмотреть как проигрывается анимация. По умолчанию она проигрывается со скоростью 60 кадров в секунду, что слишком много. Установите значение параметра Fps равным 8.
Теперь у вас есть атлас с анимацией игрока. Пока что – единственной, однако, этого уже достаточно, чтобы протестировать заготовку игры. Если хотите, добавьте остальные анимации самостоятельно.
Игровой объект Игрока
1.	Откройте main.collection.
2.	В панели Outline правым кликом по корневому элементу вызовите меню и выберите Add Game Object. Измените название (параметр Id) нового объекта на «player».
3.	Измените значение параметра Z Position объекта «player» на 1.0. Поскольку объект «map» находится по умолчанию в координате Z равной 0, объекту «player» необходимо выбрать другое значение, чтобы оказаться выше карты, иначе его будет не видно.
4.	Кликните правой кнопкой по объекту «player» и выберите Add Component > Sprite, чтобы создать для нашего игрока компонент, который будет отображать графику.
5.	Убедитесь в том, что Z Position компонента Sprite равен 0, чтобы картинка игрока отображалась на той же глубине, что и объект «player».
6.	Выберите для параметра Image графику атласа /main/sprites.atlas.
7.	В качестве анимации по умолчанию (параметр Default Animation) выберите «player-down».
8.	Запустите игру и убедитесь, что персонаж отображается и анимация работает.
Игровой объект игрока теперь имеет визуальное представление в игровом мире. Следующее, что мы сделаем - это добавим компонент скрипта, к объекту игрока. Это позволит использовать управление объектом, например – его передвижением. Но для начал надо настроить элементы управления.
Элементы управления
1.	Откройте файл «/input/game.input_bindings».  В этом файле хранится информация об источниках вводных данных (клавиатуру, сенсорный экран, игровые манипуляторы и т.д.), и команды действий (actions), которые, по сути, являются простым описанием команды.
2.	Добавьте несколько Key Triggers, соответствующих клавишам со стрелками. Назовите их actions (команды, которые будут выполняться по нажатию клавиш) - «up», «down», «left», «right».

Скрипт игрока
В отличие от компонента графики, который добавлялся непосредственно в игровой объект «player», компонент скрипта требует создания отдельного файла. После создания этот файл будет использовать в качестве основы для компонента скрипта.
1.	Кликните правой кнопкой по папке main в панели Assets и выберите New > Script. Назовите его «player» (полное название будет «player.script». Файл скрипта, заполненный по шаблону пустыми функциями, откроется в окне редактора.
2.	Откройте main.collection, нажмите правой кнопкой по объекту «player» и выберите Add Component File. В списке ресурсов выберите созданный вами «/main/player.script».
Теперь у вас есть скрипт, который выполняется в игровом объекте «player». Правда, он пока ничего не делает. Начнем с того, что научим нашего персонажа двигаться.
Перемещение игрока
Скрипт на Lua, который позволит нашему персонажу передвигаться, небольшой, но чтобы полностью разобраться в нем, может потребовать некоторое время. По



Lua код, необходимый для создания движения персонажа в 8 направлениях не долго, но может потребоваться некоторое время, чтобы полностью понять. Скопируйте код ниже и вставьте в файл player.script и запустите игру. А затем не торопясь внимательно прочитайте примечания к коду.
<код>
1.	Функция init() вызывается, когда игровой движок включает в работу компонент скрипта. Эта функция полезна для установки стартовых значений и свойств игрового объекта.
2.	В этой стройке сообщение «acquire_input_focus» передается текущему игровому объекту (точкой «.» сокращенно обозначается текущий игровой объект). Это системное сообщение, указывающее движку отправлять команды ввода этому игровому объекту. Они будут поступать в функцию on_input() этого скрипта.
3.	В коде «self» является ссылкой на текущий экземпляр компонента. Для хранения значений и состояний, которые будут использоваться локально, можно использовать self. В этой строке мы устанавливаем флаг для переменной, которая отслеживает состояние игрока – движется он или стоит на месте.
4.	Направление движения задается вектором (в любом из 8 возможных направлений), который определяется при поступлении команды, когда игрок нажимает клавиши со стрелками. Значение Z этого вектора не используется, поэтому сохраняется равным 0.
5.	«dir» - еще один вектор, который указывает направление взгляда персонажа. Этот вектор не привязан к вектору направления. И даже если команды на перемещение нет и персонаж стоит на месте, этот вектор будет работать, показывая в какую сторону повернут персонаж.
6.	«speed» - это переменная, в которой задается скорость движения, на сколько пикселей в секунду будет передвигаться персонаж.
7.	Функция final() вызывается, когда компонент скрипта будет удален из игры. Это произойдет, когда из игры будет удален игровой объект «player» или игра будет закрыта.
8.	Эта строчка кода отключает фокус ввода, сообщая движку, что команды (нажатия клавиш) от игрока больше поступать не будут. На самом деле фокус ввода автоматически снимается, когда игровой объект, на который он был настроен, будет удален из игры. Поэтому эта строка здесь не нужна, но добавлена для лучшего понимания работы движка.
9.	Функция update() вызывается каждый кадр. Если игра будет выдавать 60 кадров в секунду, эта функция будет срабатывать с интервалом в 1/60 секунды. Важным аргументом в этой строке является переменная dt (delta-time), которая обозначает время в секундах, прошедших с момента последнего тика. Она помогает поддерживать скорость игры одинаковой, в независимости от FPS.
10.	Тут у нас идет проверка, двигается ли игрок или нет. Если переменная moving имеет значение true, запрашивается текущая позиция игрового объекта. Функция go.get_position() имеет необязательный аргумент, который позволяет по id объекта получить его координаты. Если аргумент не указан, возвращает координаты текущего игрового объекта.
11.	Добавляем к координатам текущий вектор направления, с корректировкой скорости и delta-time.
12.	Записываем новые значения координат игрового объекта.
13.	После завершения расчетов, обнуляем координаты вектора направления и отключаем флаг движения.
14.	Функция on_input() вызывается каждый кадр для всех получаемых команд, которые активны на данный момент. Аргумент action_id содержит команду действия, настроенную в файле привязок ввода команд.
15.	Для каждого направления задаем значение X или Y вектора направления. Если игрок нажмет сразу две клавиши, например, «вверх» и «влево», движок вызовет эту функцию дважды и вектор направления движения установится на (-1, 1, 0).
16.	Если игрок нажимает клавиши со стрелками, величина вектора перемещения перестает быть равной 0. Если это так, устанавливаем флаг moving, чтобы действия игрока пошли в обработку в update(). Причина, по которой скрипт не делает тоже самое в функции on_input() в том, что проще собрать все входных данные каждого кадра, а потом разом задействовать их в update().
17.	Вектор направления нормализует скорость перемещения игрока. Без этого диагональное движение будет быстрее, чем горизонтальное или вертикальное.
С помощью этого скрипта на Lua в вашей игре теперь есть персонаж, который может перемещаться по экрану. Следующим шагом мы добавить возможность стрельбы ракетами.
Ракеты должны работать следующим образом: каждый раз, когда игрок нажимает клавишу, должен производиться выстрел ракетой. При этом должна быть возможность запустить несколько ракет, а не одну. Итак, как мы это сделаем? Давай рассмотрим сейчас взглянем на main.collection. Он содержит два игровых объекта: карту и персонаж игрока. Таким образом, добавление нового объекта (ракеты) в main.collection не принесет желаемого результата - ракета будет только одна. Что же делать?
То, что мы будем использовать, называется blueprint (чертеж, схема) игрового объекта, с помощью которого мы сможем создавать наши ракеты прямо во время игры. Это будет что-то вроде фабрики, которая производит нужный нам объект, когда потребуется. Давайте создадим такой чертеж.
Игровой объект ракеты
1.	Кликните правой кнопкой по папке main в панели Assets и выберите New > Game Object. Назовите его "rocket" (полное название будет "rocket.go"). (Обратите внимание, создавая этот файл, вы не создаете экземпляр игрового объекта. Это blueprint - чертеж, в котором будут описаны свойства и логика работы для игрового объекта).
2.	Перетащите папку buildings/turret-rocket из папки с материалами в папку main на панели Assets.
3.	Откройте sprites.atlas и создайте в нем новую группу анимаций (правый клик и выбрать Add Animation Group). Назовите ее "rocket".
4.	Добавьте три изображения ракеты в группу анимации и установите значение Fps таким, чтобы анимация ракеты смотрелась хорошо в окне предварительного просмотра.
5.	Откройте rocket.go, в панели Outline с помощью правого клика вызовите меню и выберите Add Component > Sprite.
6.	Для параметра Image выберите спрайт /main/sprite.atlas, а для Default Animation - "rocket".
Теперь у нас есть заготовка для игрового объекта "ракета". Теперь нам следует добавить механизм создания этого игрового объекта. Для этого будет использоваться компонент Factory. Ну и, конечно, нужно добавить новую команду ввода - для стрельбы.
Генерация игрового объекта ракеты
1.	Откройте main.collection и кликните правой кнопкой на игровом объекте "player". Выберите Add Component > Factory.
2.	Выберите только что созданный компонент и в поле Id введите название "rocketfactory", а в параметре Prototype выберите файл "/main/rocket.go" (тот, который мы создали ранее).
3.	Откройте файл "/input/game.input_binding".
4.	Добавьте клавишу для стрельбы (пусть это будет [Пробел]). Команду назовите "fire".
5.	Откройте main/player.script и добавьте переменную с флагом, которая будет отслеживать стреляет игрок в данным момент или нет. Изначально в функции init() значение установлено в false. Но когда игрок будет нажимать клавишу выстрела, флаг будет установлен в true.
6.	В update() нужно добавить действи, которое должно произойти, когда флаг из предыдущей строки будет установлен: компонент Factory должен создать экземпляр нового игрового объекта.
o	Если firing = true, движок сообщает компоненту "rocketfactory", который вы только что создали, что тот должен создать новый игровой объект. Обратите внимание на символ '#', который указывает, что это Id компонента.
o	Флаг firing принимает значение false. Противоположное значение он будет принимать в функции on_input(), в каждом кадре, пока игрок нажимает клавишу выстрела.
7.	Теперь найдите функцию on_input(). Добавьте в нее четвертый elseif для проверки нажатия клавиши выстрела. Так же здесь указано дополнительное условие, не позволяющее делать более одного выстрела за одно нажатие клавиши.
Если вы сейчас запустите игру, то сможете перемещаться и разбрасывать ракеты по всей карте, нажимая клавишу выстрела. Неплохой результат, только нужно исправитье пару вещей:
•	Когда создается ракета, она должна двигаться в направлении, куда двигался игрок.
•	Ракета должна взорваться через короткий промежуток времени.
Настройка направления ракеты
1.	Откройте player.script и прокрутите вниз до функции update() и обновите его код:
<код>
1. Вычисляем угол (в радианах) поворота персонажа игрока.
2. Создаем кватернион для этого углового вращения вокруг оси Z.
3. Создаем таблицу (массив) значений свойств, передаваемых ракете. В нашем случае направление игрока - это единственные данные, которые нужны ракете.
4. Задаем координаты ракете (nil - ракета появится в позиции игрока), угол поворота и значения свойств.
Обратите внимание, что ракете требуется направление движения в дополнение к направление угла поворота ( rot ). Можно сделать так, чтобы ракета вычислила вектор движения на основе угла поворота, но легче и гибче разделить эти два значения. Например, с отдельным направлением поворота можно добавить вращательное колебание к ракете, которое не будет влиять на направление движения.
2.	Щелкните правой кнопкой мыши по папке main в панели Assets и выберите New > Script .Назовите новый скрипт «rocket» (полное название будет «rocket.script»). Замените код шаблона в файле следующим текстом:
<код>
1. Определите новое свойство с именем dir и инициализируйте его пустым вектором по умолчанию (vmath.vector3()). 
2. Значение скорости ракеты, выраженное в пикселях в секунду.
3. Получаем текущую позицию ракеты.
4. Рассчитываем новую позицию на основе старой позиции, направления движения и скорости.
5. Устанавливаем новую позицию.
3.	Откройте rocket.go и щелкните правой кнопкой мыши по нему в панели Outline и выберите Add Component File. В качестве основы для компонента выберите файл «rocket.script».
4.	Запустите игру и опопробуйте новую механика. Обратите внимание, что ракеты летят в правильном направлении, но при этом развернуты на 180 градусов. Это легко исправить.
5.	Откройте sprites.atlas , выберите анимацию «rocket» и нажмите свойство Flip horizontal.
6.	Запустите игру еще раз, чтобы убедиться, что теперь все выглядит нормально.
Теперь нам нужно сделать так, чтобы ракета взрывалась через несколько мгновение после пуска.
Взрывы

1.	Перетащите папку fx/explosion из папки с метариалами в папку main в панели Assets.
2.	Откройте sprites.atlas и создайте новую группу анимации (щелкните правой кнопкой мыши корневой узел и выберите Add Animation Group). Назовите новую анимацию «explosion».
3.	Добавьте девять изображений взрыва в группу анимации и установите для свойства Fps значение, при котором анимация будет смотреться хорошо при предварительном просмотре. Также убедитесь, что у этой анимации свойство Playback установлено на Once Forward (чтобы она проигрывалась всего один раз).
4.	Откройте файл rocket.script и прокрутите вниз до функции init() и измените его на:
<код>
1.	Это значение будет таймером, отслеживающим срок жизни ракеты.
5.	Прокрутите вниз до функции update() и измените ее на:
<код>
1.	Уменьшаем таймер жизни используя переменную delta-time. Он будет уменьшаться на 1.0 в секунду.
2.	Условие: если таймер станет ниже нуля, тогда…
3.	Установим время жизни на большое значение, чтобы этот код не запускался при каждом последующем обновлении.
4.	Установим поворот игрового объекта на 0, иначе графика взрыва будет повернута.
5.	Установим скорость движения на 0, иначе графика взрыва будет двигаться.
6.	Отправляем команду на воспроизведите анимации «explosion» на компоненте «sprite» игрового объекта.
6.	Ниже функции update() добавьте новую функцию on_message():
<код>
1.	Функция on_message() вызывается каждый раз, когда отправляется сообщение этому компоненту скрипта.
2.	Проверяем, имеет ли отправленное сообщение хешированное имя (или id) «animation_done». Движок отправляет это сообщение всякий раз, когда завершена анимация спрайтов, запущенная сообщением «play_animation» из этого скрипта.
3.	Если завершение анимации подтверждено, удаляем текущий игровой объект.
Запустите игру.
Ну вот, это уже смотрится круто! Но нам определенно нужно что-то, во что можно пострелять ракетами, не так ли?
Игровой объект Танк
1.	Щелкните правой кнопкой мыши по папке main в панели Assets и выберите New > Game Object. Назовите этот файл «tank» (полное название будет «tank.go»). Так же, как и игровой объекты ракеты, это файл, который будет использоваться в качестве blueprint для создания игрового объекта танка.
2.	Перетащите папку units/tank из папки с материалами в папку main в панели Assets.
3.	Откройте sprites.atlas и создайте новую группу анимации (щелкните правой кнопкой мыши корневой узел и выберите Add Animation Group ). Назовите анимацию «tank-down».
4.	Добавьте два изображения танка ( /main/tank/down/1.png и /main/tank/down/2.png ) в анимацию и установите для нее подходящее значение Fps.
5.	Откройте tank.go, щелкните по нему правой кнопкой мыши в панели Outline и выберите Ass Component > Sprite.
6.	Установите для свойства Image спрайт /main/sprites.atlas, дла  Default Animation - «tank-down».
7.	Откройте main.collection
8.	Щелкните правой кнопкой мыши по нему в панели Outline и выберите Add Game Object File. Выберите tank.go в качестве заготовки для нового игрового объекта.
9.	Создайте таким же образом еще несколько танков. Разместите их на карте с помощью инструмента «Move Tool». И не забудьте установить координату Z в 1.0, чтобы они отображались поверх карты.

Запустите игру и убедитесь, что танки появились на карте. Если сейчас выстрелить в них, ракеты будут пролетать сквозь танки. Следующим шагом мы добавим столкновение между танками и ракетами.
Добавление объектов столкновения 
1.	Откройте tank.go, щелкните правой кнопкой мыши по нему в панели Outline и выберите Add Component > Collision Object.
2.	Установите для свойства Type значение «Kinematic». Это означает, что физический движок не будет имитировать гравитацию или столкновения на этом объекте. Вместо этого он будет обнаруживать и сообщать о столкновениях для последующей обработки.
3.	Установите для свойства Group значение «tanks», для Mask - «rockets». Так мы задаем механику, что этот игровой объект будет обнаруживать столкновения с объектом из группы «rockets», у которого, в свою очередь, в Mask, будет указана группа «tanks».
4.	Щелкните правой кнопкой мыши по компоненту «collisionobject» в панели Outline и выберите Add Shape > Box. Подгоните размер формы этого компонента в соответствии с картинкой танка.

5.	Откройте rocket.go, щелкните правой кнопкой мыши по нему в панели Ouline и выберите Add Component > Collision Object.
6.	Установите для свойства Type значение «Kinematic».
7.	Установите для свойства Group значение «rockets», для Mask - «tanks». Теперь наши ракеты будут отслеживать столкновения с танками.
8.	Щелкните правой кнопкой мыши по компоненту «collisionobject» в панели Outline и выберите Add Shape > Box. Подгоните размер формы этого компонента в соответствии с картинкой ракеты.
Теперь группы и маски ракет и танков настроены друг на друга, поэтому физический движок будет обнаруживать их столкновения.
Остался последний этап – написать код скрипта, который будет обрабатывать попадания ракет в танки.

Реакция на столкновения 
1.	Откройте файл rocket.script и промотайте вниз до функции update() . Здесь нужно сделать несколько изменений:
<код>
1.	Поскольку нам нужно, чтобы ракета взорвалась либо при истечении таймера (в update()), либо когда ракета попала в танк (в on_message()), вы должны убрать эту часть кода, чтобы избежать дублирования. Для взрыва ракеты мы будем использовать локальную функцию. Когда функция объявлена как local , это означает, что она существует только в рамках скрипта ракеты. В правилах обзора Lua указано, что локальные функции должны быть объявлены до их использования. Поэтому функция помещается над update() . Также убедитесь, что вы передаете self как параметр функции, чтобы вы могли получить доступ к self.life и т.д.
2.	Код, который раньше был здесь, теперь перемещен в функцию explode() .
3.	Движок будет отправлять сообщение «collision_response», когда объекты столкнутся, при этом учитывается правильное сочетание групп и масок.
4.	Функцию explode() вызывается, если есть столкновение.
5.	Удаляем танк. Движок получает идентификатор игрового объекта, с которым столкнулась ракета с помощью переменной message.other_id .
Запустите игру и уничтожьте несколько танков! Танки не очень интересные враги, но тем не менее, за их уничтожение игрок должен получать очки.

Графический интерфейс подсчета очков 
1.	Перетащите файл «fonts/04font.ttf» из папки с материалами в папку main в панели Assets.
2.	Щелкните правой кнопкой мыши по папке main в панели Assets и выберите New > Font. Назовите этот файл «text» (полное название будет «text.font»).
3.	Откройте text.font и установите для свойства Font файл «04font.ttf».
4.	Щелкните правой кнопкой мыши по папке main в панели Assets и выберите New > GUI. Назовите этот файл "ui" (полное название будет "ui.gui"). Он будет содержать пользовательский интерфейс, в котором вы поместите счетчик очков.
5.	Откройте «ui.gui». Щелкните правой кнопкой мыши по Fonts в панели Outline и выберите Add ▸ Fonts. Выберите файл «/main/text.font».
6.	Щелкните правой кнопкой мыши по Nodes в панели Outline и выберите Add > Text.
7.	Кликните по созданному текстовому и установите для Id значение «score», а в поле Text напишите «SCORE: 0». Для свойства Font выберите шрифт «text», а для параметра Pivot - «West».
8.	Поместите текстовой блок в верхнем левом углу экрана.
9.	Щелкните правой кнопкой мыши по папке main в панели Assets и выберите New > Gui Script. Назовите этот новый файл «ui» (полное название будет «ui.gui_script»).
10.	Вернитесь к «ui.gui» и кликните по нему в панели Outline. Задайте свойство Script файл «/main/ui.gui_script», который вы только что создали. Теперь, если мы добавим этот Gui в качестве компонента к игровому объекту, Gui будет отображаться и скрипт будет запущен.
11.	Откройте main.collection .
12.	Щелкните правой кнопкой мыши по нему в панели Outline и выберите Add Game Object.
13.	Установите для свойства Id объекта значение «gui», затем щелкните правой кнопкой мыши и выберите Add Component File. Выберите файл «/main/ui.gui». Новый компонент автоматически получит Id «ui».

Теперь на экране отображается счетчик очков. Нам осталось добавить функциональность в скрипт Gui, чтобы счетчик обновлялся.
Обновление счетчика очков 
1.	Откройте ui.gui_script
2.	Замените код шаблона следующим:
<код>
1.	Задаем переменную текущего счета в self. Изначально она равна 0.
2.	Реакция на сообщение с именем «add_score».
3.	Прибавляем к текущему значению в переменной число, переданное в сообщении.
4.	Определяем в переменную текстовой блок с именем «score», который создали в Gui.
5.	Обновляем текстовой блок до строки «SCORE:» и подставляем текущее количество очков в конец строки.
3.	Откройте rocket.script и промотайте вниз до функции on_message(), где вам нужно добавить одну новую строку кода:
<код>
1.	Отправляем сообщение с именем «add_score» в компонент «ui» в игровом объекте с именем «gui» в корневой части основной коллекции. Количество очков очков берем из таблицы, где значение поля score равно 100.
4.	Попробуйте поиграть!

